<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sitio en Mantenimiento</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #e2e8f0;
        padding: 10px;
      }

      .maintenance-container {
        background: rgba(30, 41, 59, 0.8);
        backdrop-filter: blur(10px);
        /* border: 1px solid rgba(59, 130, 246, 0.2); */
        border-radius: 15px;
        padding: 30px;
        max-width: 480px;
        width: 100%;
        text-align: center;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      }

      .icon {
        width: 60px;
        height: 60px;
        background: linear-gradient(135deg, #3b82f6, #06b6d4);
        border-radius: 50%;
        margin: 0 auto 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: white;
        box-shadow: 0 10px 25px rgba(59, 130, 246, 0.3);
      }

      h1 {
        font-size: 2rem;
        font-weight: 700;
        color: #06b6d4;
        margin-bottom: 10px;
        text-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
      }

      .subtitle {
        font-size: 1rem;
        color: #94a3b8;
        margin-bottom: 25px;
      }

      .game-container {
        position: relative;
        width: 100%;
        height: 280px;
        margin: 25px 0 15px;
        background: linear-gradient(
          135deg,
          rgba(15, 23, 42, 0.8),
          rgba(30, 41, 59, 0.6)
        );
        border-radius: 5px;
        /* border: 1px solid rgba(6, 182, 212, 0.3); */
        overflow: hidden;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      #pacman-game {
        width: 100%;
        height: 100%;
        display: block;
        cursor: pointer;
        touch-action: none;
      }

      .score-display {
        background: linear-gradient(
          135deg,
          rgba(15, 23, 42, 0.9),
          rgba(30, 41, 59, 0.8)
        );
        padding: 6px 12px;
        border-radius: 10px;
        font-size: 0.85rem;
        color: #06b6d4;
        border: 1px solid rgba(6, 182, 212, 0.4);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(5px);
        margin-bottom: 12px;
        display: inline-block;
      }

      .game-instructions {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.8rem;
        color: #94a3b8;
        margin-bottom: 20px;
        padding: 12px;
        background: linear-gradient(
          135deg,
          rgba(15, 23, 42, 0.6),
          rgba(30, 41, 59, 0.4)
        );
        border-radius: 10px;
        border: 1px solid rgba(6, 182, 212, 0.2);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .game-instructions kbd {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.4),
          rgba(6, 182, 212, 0.3)
        );
        border: 1px solid rgba(59, 130, 246, 0.5);
        border-radius: 4px;
        padding: 2px 6px;
        font-family: monospace;
        margin: 0 1px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        font-size: 0.75rem;
      }

      .desktop-instructions {
        display: block;
      }

      .mobile-instructions {
        display: none;
      }

      .description {
        font-size: 0.9rem;
        line-height: 1.5;
        color: #cbd5e1;
        margin-bottom: 20px;
      }

      .contact-info {
        font-size: 0.8rem;
        color: #64748b;
      }

      .contact-link {
        color: #06b6d4;
        text-decoration: none;
        transition: color 0.3s ease;
      }

      .contact-link:hover {
        color: #0891b2;
        text-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
      }

      /* Controles táctiles para móvil */
      .mobile-controls {
        display: none;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        max-width: 160px;
        margin: 12px auto;
      }

      .control-btn {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.4),
          rgba(6, 182, 212, 0.3)
        );
        border: 1px solid rgba(59, 130, 246, 0.5);
        border-radius: 8px;
        color: #e2e8f0;
        font-size: 16px;
        cursor: pointer;
        user-select: none;
        transition: all 0.2s ease;
        touch-action: manipulation;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1/1;
      }

      .control-btn:active {
        transform: scale(0.95);
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.6),
          rgba(6, 182, 212, 0.5)
        );
      }

      .control-btn.empty {
        opacity: 0;
        pointer-events: none;
      }

      /* Custom arrow styles for mobile controls */
      .custom-arrow {
        display: inline-block;
        width: 0;
        height: 0;
        border-style: solid;
      }
      .custom-arrow.up {
        border-width: 0 11px 18px 11px;
        border-color: transparent transparent #06b6d4 transparent;
        position: relative;
        bottom: 1px;
      }
      .custom-arrow.down {
        border-width: 18px 11px 0 11px;
        border-color: #06b6d4 transparent transparent transparent;
        position: relative;
        top: 1px;
      }
      .custom-arrow.left {
        border-width: 11px 18px 11px 0;
        border-color: transparent #06b6d4 transparent transparent;
        position: relative;
        right: 1px;
      }
      .custom-arrow.right {
        border-width: 11px 0 11px 18px;
        border-color: transparent transparent transparent #06b6d4;
        position: relative;
        left: 1px;
      }

      /* Responsive breakpoints */
      @media (max-width: 768px) {
        body {
          padding: 15px;
          align-items: center;
          justify-content: center;
        }

        .maintenance-container {
          padding: 20px;
          max-width: 480px;
          width: 100%;
          margin: 0;
        }

        .icon {
          width: 50px;
          height: 50px;
          font-size: 20px;
          margin-bottom: 15px;
        }

        h1 {
          font-size: 1.6rem;
          margin-bottom: 8px;
        }

        .subtitle {
          font-size: 0.9rem;
          margin-bottom: 20px;
        }

        .game-container {
          /* height: 220px; */
          margin: 20px 0 12px;
        }

        .mobile-controls {
          display: grid;
        }

        .desktop-instructions {
          display: none;
        }

        .mobile-instructions {
          display: block;
        }

        .game-instructions {
          font-size: 0.75rem;
          padding: 10px;
          margin-bottom: 15px;
        }

        .game-instructions kbd {
          font-size: 0.7rem;
          padding: 1px 4px;
        }

        .description {
          font-size: 0.8rem;
          margin-bottom: 15px;
        }

        .contact-info {
          font-size: 0.75rem;
        }

        .score-display {
          font-size: 0.8rem;
          padding: 5px 10px;
          margin-bottom: 10px;
        }
      }

      @media (max-width: 480px) {
        body {
          padding: 10px;
        }

        .maintenance-container {
          padding: 15px;
          border-radius: 15px;
        }

        .icon {
          width: 45px;
          height: 45px;
          font-size: 18px;
          margin-bottom: 12px;
        }

        h1 {
          font-size: 1.4rem;
          margin-bottom: 6px;
        }

        .subtitle {
          font-size: 0.85rem;
          margin-bottom: 15px;
        }

        .game-container {
          height: 200px;
          margin: 15px 0 10px;
          border-radius: 12px;
        }

        .mobile-controls {
          max-width: 160px;
          gap: 6px;
        }

        .control-btn {
          padding: 10px;
          font-size: 14px;
          min-height: 40px;
          border-radius: 6px;
        }

        .game-instructions {
          font-size: 0.7rem;
          padding: 8px;
          margin-bottom: 12px;
          border-radius: 8px;
        }

        .game-instructions kbd {
          font-size: 0.65rem;
          padding: 1px 3px;
          margin: 0 1px;
        }

        .description {
          font-size: 0.75rem;
          line-height: 1.4;
          margin-bottom: 12px;
        }

        .contact-info {
          font-size: 0.7rem;
        }

        .score-display {
          font-size: 0.75rem;
          padding: 4px 8px;
          margin-bottom: 8px;
          border-radius: 8px;
        }
      }

      @media (max-width: 360px) {
        .maintenance-container {
          padding: 12px;
        }

        h1 {
          font-size: 1.3rem;
        }

        .game-container {
          height: 180px;
        }

        .mobile-controls {
          max-width: 140px;
        }

        .control-btn {
          padding: 8px;
          font-size: 12px;
          min-height: 35px;
        }
      }

      /* Landscape orientation for mobile */
      @media (max-height: 600px) and (orientation: landscape) {
        body {
          padding: 5px;
          align-items: center;
        }

        .maintenance-container {
          padding: 10px;
          max-height: 95vh;
          overflow-y: auto;
        }

        .icon {
          width: 40px;
          height: 40px;
          font-size: 16px;
          margin-bottom: 8px;
        }

        h1 {
          font-size: 1.2rem;
          margin-bottom: 4px;
        }

        .subtitle {
          font-size: 0.8rem;
          margin-bottom: 10px;
        }

        .game-container {
          height: 160px;
          margin: 10px 0 8px;
        }

        .mobile-controls {
          max-width: 120px;
          gap: 4px;
        }

        .control-btn {
          padding: 6px;
          font-size: 12px;
          min-height: 30px;
        }

        .game-instructions,
        .description,
        .contact-info {
          font-size: 0.65rem;
          margin-bottom: 8px;
        }
      }
    </style>
  </head>
  <body>
    <div class="maintenance-container">
      <div class="icon">🔧</div>

      <h1>En Mantenimiento</h1>
      <p class="subtitle">Estamos realizando algunas mejoras</p>

      <div class="game-container">
        <canvas id="pacman-game"></canvas>
      </div>

      <div class="score-display">Puntos: <span id="score">0</span></div>

      <!-- Controles táctiles para móvil -->
      <div class="mobile-controls">
        <div class="control-btn empty"></div>
        <div class="control-btn" data-direction="up">
          <span class="custom-arrow up"></span>
        </div>
        <div class="control-btn empty"></div>
        <div class="control-btn" data-direction="left">
          <span class="custom-arrow left"></span>
        </div>
        <div class="control-btn empty"></div>
        <div class="control-btn" data-direction="right">
          <span class="custom-arrow right"></span>
        </div>
        <div class="control-btn empty"></div>
        <div class="control-btn" data-direction="down">
          <span class="custom-arrow down"></span>
        </div>
        <div class="control-btn empty"></div>
      </div>

      <div class="game-instructions">
        <strong>¡Juega Pacman mientras esperas!</strong>
        <span class="desktop-instructions">
          <kbd>←</kbd> <kbd>↑</kbd> <kbd>→</kbd> <kbd>↓</kbd> o <kbd>W</kbd>
          <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd>
        </span>
        <span class="mobile-instructions">
          Toca las flechas <kbd>←</kbd> <kbd>↑</kbd> <kbd>→</kbd> <kbd>↓</kbd> o
          desliza la pantalla
        </span>
      </div>

      <div class="description">
        Nuestro sitio web está actualmente en mantenimiento programado para
        mejorar tu experiencia. Estaremos de vuelta en línea pronto. ¡Gracias
        por tu paciencia!
      </div>

      <div class="contact-info">
        ¿Necesitas asistencia inmediata?<br />
        Contáctanos en
        <a href="mailto:soporte@tusitio.com" class="contact-link"
          >soporte@tusitio.com</a
        >
      </div>
    </div>

    <script>
      class PacmanGame {
        constructor() {
          this.canvas = document.getElementById("pacman-game");
          this.ctx = this.canvas.getContext("2d");
          this.scoreElement = document.getElementById("score");
          this.cellSize = 20;
          this.score = 0;
          this.gameOver = false;
          this.gameWon = false;
          this.dotCount = 0;
          this.isMobile = this.detectMobile();

          // Variables para gestos táctiles
          this.touchStartX = 0;
          this.touchStartY = 0;
          this.touchEndX = 0;
          this.touchEndY = 0;
          this.minSwipeDistance = 30;

          // Control de velocidad con interpolación suave
          this.moveCounter = 0;
          this.moveDelay = 8; // Frames entre movimientos discretos

          // Posiciones suaves para interpolación
          this.pacmanSmoothPos = { x: 1, y: 1 };
          this.ghostSmoothPos = [];

          // Ajustar el tamaño del canvas al contenedor
          this.resizeCanvas();
          window.addEventListener("resize", () => this.resizeCanvas());

          // Inicializar el juego
          this.init();

          // Configurar controles
          this.setupControls();
          this.setupMobileControls();
          this.setupSwipeControls();

          // Iniciar bucle del juego
          this.gameLoop();
        }

        detectMobile() {
          return (
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            ) || window.innerWidth <= 768
          );
        }

        resizeCanvas() {
          const container = this.canvas.parentElement;
          this.canvas.width = container.offsetWidth;
          this.canvas.height = container.offsetHeight;

          // Recalcular tamaño de celda basado en el nuevo tamaño
          const gridWidth = 15;
          const gridHeight = 10;
          this.cellSize = Math.min(
            Math.floor(this.canvas.width / gridWidth),
            Math.floor(this.canvas.height / gridHeight)
          );

          // Si el juego ya está inicializado, recrear el mapa
          if (this.map) {
            this.createMap();
          }
        }

        init() {
          // Definir el mapa (0: vacío, 1: pared, 2: punto, 3: poder)
          this.mapLayout = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1],
            [1, 2, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1],
            [1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 1],
            [1, 1, 1, 2, 1, 2, 2, 2, 2, 3, 1, 2, 1, 1, 1],
            [1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1],
            [1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1],
            [1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          ];

          this.createMap();

          // Inicializar Pacman
          this.pacman = {
            x: 1,
            y: 1,
            targetX: 1,
            targetY: 1,
            direction: { x: 0, y: 0 },
            nextDirection: { x: 0, y: 0 },
            color: "#FFFF00",
            mouthAngle: 0,
            mouthDirection: 1,
            moveProgress: 0,
          };

          // Inicializar fantasmas con movimiento suave (ahora 3 fantasmas)
          this.ghosts = [
            {
              x: 13,
              y: 1,
              targetX: 13,
              targetY: 1,
              direction: { x: -1, y: 0 },
              color: "#FF4444",
              moveCounter: 0,
              moveProgress: 0,
              moveDelay: 10,
            },
            {
              x: 13,
              y: 8,
              targetX: 13,
              targetY: 8,
              direction: { x: 0, y: -1 },
              color: "#44FFFF",
              moveCounter: 0,
              moveProgress: 0,
              moveDelay: 12,
            },
            {
              x: 1,
              y: 8,
              targetX: 1,
              targetY: 8,
              direction: { x: 1, y: 0 },
              color: "#FF44FF",
              moveCounter: 0,
              moveProgress: 0,
              moveDelay: 11,
            },
          ];

          // Inicializar posiciones suaves
          this.pacmanSmoothPos = { x: 1, y: 1 };
          this.ghostSmoothPos = [
            { x: 13, y: 1 },
            { x: 13, y: 8 },
            { x: 1, y: 8 },
          ];

          // Contador de puntos
          this.countDots();

          // Reiniciar puntuación
          this.score = 0;
          this.updateScore();

          // Reiniciar estado del juego
          this.gameOver = false;
          this.gameWon = false;

          // Reiniciar contadores
          this.moveCounter = 0;
        }

        countDots() {
          this.dotCount = 0;
          for (let y = 0; y < this.map.length; y++) {
            for (let x = 0; x < this.map[y].length; x++) {
              if (this.map[y][x] === 2 || this.map[y][x] === 3) {
                this.dotCount++;
              }
            }
          }
        }

        createMap() {
          // Calcular el offset para centrar el mapa
          const mapWidth = this.mapLayout[0].length * this.cellSize;
          const mapHeight = this.mapLayout.length * this.cellSize;
          this.offsetX = (this.canvas.width - mapWidth) / 2;
          this.offsetY = (this.canvas.height - mapHeight) / 2;

          // Crear copia del mapa
          this.map = JSON.parse(JSON.stringify(this.mapLayout));
        }

        setupControls() {
          document.addEventListener("keydown", (e) => {
            this.handleInput(e.key);
            e.preventDefault();
          });

          // Agregar evento de click/touch al canvas para reiniciar
          this.canvas.addEventListener("click", (e) => {
            if (this.gameOver || this.gameWon) {
              this.init();
            }
          });

          this.canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            if (this.gameOver || this.gameWon) {
              this.init();
            }
          });
        }

        setupMobileControls() {
          const controlBtns = document.querySelectorAll(
            ".control-btn[data-direction]"
          );
          controlBtns.forEach((btn) => {
            btn.addEventListener("touchstart", (e) => {
              e.preventDefault();
              const direction = btn.getAttribute("data-direction");
              this.handleMobileInput(direction);
            });

            btn.addEventListener("click", (e) => {
              e.preventDefault();
              const direction = btn.getAttribute("data-direction");
              this.handleMobileInput(direction);
            });
          });
        }

        setupSwipeControls() {
          this.canvas.addEventListener("touchstart", (e) => {
            if (this.gameOver || this.gameWon) return;

            e.preventDefault();
            const touch = e.touches[0];
            this.touchStartX = touch.clientX;
            this.touchStartY = touch.clientY;
          });

          this.canvas.addEventListener("touchend", (e) => {
            if (this.gameOver || this.gameWon) return;

            e.preventDefault();
            const touch = e.changedTouches[0];
            this.touchEndX = touch.clientX;
            this.touchEndY = touch.clientY;
            this.handleSwipe();
          });

          // Prevenir scroll en el canvas
          this.canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
          });
        }

        handleSwipe() {
          const deltaX = this.touchEndX - this.touchStartX;
          const deltaY = this.touchEndY - this.touchStartY;
          const absDeltaX = Math.abs(deltaX);
          const absDeltaY = Math.abs(deltaY);

          // Verificar si el swipe es lo suficientemente largo
          if (Math.max(absDeltaX, absDeltaY) < this.minSwipeDistance) {
            return;
          }

          // Determinar la dirección del swipe
          if (absDeltaX > absDeltaY) {
            // Swipe horizontal
            if (deltaX > 0) {
              this.pacman.nextDirection = { x: 1, y: 0 }; // Derecha
            } else {
              this.pacman.nextDirection = { x: -1, y: 0 }; // Izquierda
            }
          } else {
            // Swipe vertical
            if (deltaY > 0) {
              this.pacman.nextDirection = { x: 0, y: 1 }; // Abajo
            } else {
              this.pacman.nextDirection = { x: 0, y: -1 }; // Arriba
            }
          }
        }

        handleInput(key) {
          switch (key) {
            case "ArrowUp":
            case "w":
            case "W":
              this.pacman.nextDirection = { x: 0, y: -1 };
              break;
            case "ArrowDown":
            case "s":
            case "S":
              this.pacman.nextDirection = { x: 0, y: 1 };
              break;
            case "ArrowLeft":
            case "a":
            case "A":
              this.pacman.nextDirection = { x: -1, y: 0 };
              break;
            case "ArrowRight":
            case "d":
            case "D":
              this.pacman.nextDirection = { x: 1, y: 0 };
              break;
            case " ":
              // Reiniciar juego si está terminado
              if (this.gameOver || this.gameWon) {
                this.init();
              }
              break;
          }
        }

        handleMobileInput(direction) {
          switch (direction) {
            case "up":
              this.pacman.nextDirection = { x: 0, y: -1 };
              break;
            case "down":
              this.pacman.nextDirection = { x: 0, y: 1 };
              break;
            case "left":
              this.pacman.nextDirection = { x: -1, y: 0 };
              break;
            case "right":
              this.pacman.nextDirection = { x: 1, y: 0 };
              break;
          }
        }

        updateScore() {
          this.scoreElement.textContent = this.score;
        }

        gameLoop() {
          // Limpiar canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Actualizar estado del juego
          if (!this.gameOver && !this.gameWon) {
            this.update();
          }

          // Dibujar elementos
          this.draw();

          // Continuar bucle
          requestAnimationFrame(() => this.gameLoop());
        }

        update() {
          // Incrementar contador principal
          this.moveCounter++;

          // Actualizar Pacman
          this.updatePacman();

          // Animar boca de Pacman
          this.animatePacmanMouth();

          // Actualizar fantasmas
          this.updateGhosts();

          // Comprobar colisiones
          this.checkCollisions();

          // Comprobar victoria
          if (this.dotCount === 0) {
            this.gameWon = true;
          }
        }

        updatePacman() {
          // Si Pacman está en movimiento, interpolar
          if (this.pacman.moveProgress < 1) {
            this.pacman.moveProgress += 1 / this.moveDelay;
            if (this.pacman.moveProgress >= 1) {
              this.pacman.moveProgress = 1;
              // Movimiento completado, actualizar posición real
              this.pacman.x = this.pacman.targetX;
              this.pacman.y = this.pacman.targetY;
            }
          }

          // Si el movimiento está completo, intentar nuevo movimiento
          if (
            this.pacman.moveProgress >= 1 &&
            this.moveCounter >= this.moveDelay
          ) {
            this.tryChangeDirection();
            this.movePacman();
            this.moveCounter = 0;
          }

          // Actualizar posición suave para renderizado
          this.pacmanSmoothPos.x =
            this.pacman.x +
            (this.pacman.targetX - this.pacman.x) * this.pacman.moveProgress;
          this.pacmanSmoothPos.y =
            this.pacman.y +
            (this.pacman.targetY - this.pacman.y) * this.pacman.moveProgress;
        }

        updateGhosts() {
          this.ghosts.forEach((ghost, index) => {
            ghost.moveCounter++;

            // Si el fantasma está en movimiento, interpolar
            if (ghost.moveProgress < 1) {
              ghost.moveProgress += 1 / ghost.moveDelay;
              if (ghost.moveProgress >= 1) {
                ghost.moveProgress = 1;
                // Movimiento completado, actualizar posición real
                ghost.x = ghost.targetX;
                ghost.y = ghost.targetY;
              }
            }

            // Si el movimiento está completo, intentar nuevo movimiento
            if (
              ghost.moveProgress >= 1 &&
              ghost.moveCounter >= ghost.moveDelay
            ) {
              this.moveGhost(ghost);
              ghost.moveCounter = 0;
            }

            // Actualizar posición suave para renderizado
            this.ghostSmoothPos[index].x =
              ghost.x + (ghost.targetX - ghost.x) * ghost.moveProgress;
            this.ghostSmoothPos[index].y =
              ghost.y + (ghost.targetY - ghost.y) * ghost.moveProgress;
          });
        }

        tryChangeDirection() {
          const nextX = this.pacman.x + this.pacman.nextDirection.x;
          const nextY = this.pacman.y + this.pacman.nextDirection.y;

          // Comprobar si la nueva dirección es válida
          if (
            nextX >= 0 &&
            nextX < this.map[0].length &&
            nextY >= 0 &&
            nextY < this.map.length &&
            this.map[nextY][nextX] !== 1
          ) {
            this.pacman.direction = { ...this.pacman.nextDirection };
          }
        }

        movePacman() {
          const nextX = this.pacman.x + this.pacman.direction.x;
          const nextY = this.pacman.y + this.pacman.direction.y;

          // Comprobar si el movimiento es válido
          if (
            nextX >= 0 &&
            nextX < this.map[0].length &&
            nextY >= 0 &&
            nextY < this.map.length &&
            this.map[nextY][nextX] !== 1
          ) {
            // Recoger punto
            if (this.map[nextY][nextX] === 2) {
              this.map[nextY][nextX] = 0;
              this.score += 10;
              this.dotCount--;
              this.updateScore();
            }
            // Recoger poder
            else if (this.map[nextY][nextX] === 3) {
              this.map[nextY][nextX] = 0;
              this.score += 50;
              this.dotCount--;
              this.updateScore();
            }

            // Iniciar movimiento suave
            this.pacman.targetX = nextX;
            this.pacman.targetY = nextY;
            this.pacman.moveProgress = 0;
          }
        }

        moveGhost(ghost) {
          // Probabilidad de cambiar dirección
          if (Math.random() < 0.4) {
            const possibleDirections = [];

            // Comprobar direcciones posibles
            const directions = [
              { x: 0, y: -1 }, // Arriba
              { x: 0, y: 1 }, // Abajo
              { x: -1, y: 0 }, // Izquierda
              { x: 1, y: 0 }, // Derecha
            ];

            directions.forEach((dir) => {
              const nextX = ghost.x + dir.x;
              const nextY = ghost.y + dir.y;

              // Evitar retroceder (a veces)
              const isOpposite =
                dir.x === -ghost.direction.x && dir.y === -ghost.direction.y;

              if (
                (!isOpposite || Math.random() < 0.1) &&
                nextX >= 0 &&
                nextX < this.map[0].length &&
                nextY >= 0 &&
                nextY < this.map.length &&
                this.map[nextY][nextX] !== 1
              ) {
                possibleDirections.push(dir);
              }
            });

            // Si hay direcciones posibles, elegir una aleatoria
            if (possibleDirections.length > 0) {
              const randomIndex = Math.floor(
                Math.random() * possibleDirections.length
              );
              ghost.direction = possibleDirections[randomIndex];
            }
          }

          // Intentar mover en la dirección actual
          const nextX = ghost.x + ghost.direction.x;
          const nextY = ghost.y + ghost.direction.y;

          if (
            nextX >= 0 &&
            nextX < this.map[0].length &&
            nextY >= 0 &&
            nextY < this.map.length &&
            this.map[nextY][nextX] !== 1
          ) {
            // Iniciar movimiento suave
            ghost.targetX = nextX;
            ghost.targetY = nextY;
            ghost.moveProgress = 0;
          } else {
            // Si hay pared, invertir dirección
            ghost.direction.x *= -1;
            ghost.direction.y *= -1;
          }
        }

        animatePacmanMouth() {
          // Animar la boca de Pacman más suavemente
          this.pacman.mouthAngle += 0.05 * this.pacman.mouthDirection;
          if (this.pacman.mouthAngle > 0.4) {
            this.pacman.mouthDirection = -1;
          } else if (this.pacman.mouthAngle < 0.05) {
            this.pacman.mouthDirection = 1;
          }
        }

        checkCollisions() {
          // Comprobar colisiones con fantasmas usando posiciones suaves
          this.ghostSmoothPos.forEach((ghostPos) => {
            const distance = Math.sqrt(
              Math.pow(ghostPos.x - this.pacmanSmoothPos.x, 2) +
                Math.pow(ghostPos.y - this.pacmanSmoothPos.y, 2)
            );
            if (distance < 0.7) {
              this.gameOver = true;
            }
          });
        }

        draw() {
          // Dibujar mapa
          this.drawMap();

          // Dibujar Pacman
          this.drawPacman();

          // Dibujar fantasmas
          this.drawGhosts();

          // Dibujar mensaje de fin de juego
          if (this.gameOver) {
            this.drawGameMessage("¡Game Over!", "#FF4444");
          } else if (this.gameWon) {
            this.drawGameMessage("¡Victoria!", "#44FF44");
          }
        }

        drawMap() {
          for (let y = 0; y < this.map.length; y++) {
            for (let x = 0; x < this.map[y].length; x++) {
              const cellX = this.offsetX + x * this.cellSize;
              const cellY = this.offsetY + y * this.cellSize;

              switch (this.map[y][x]) {
                case 1: // Pared con gradiente y bordes elegantes
                  const gradient = this.ctx.createLinearGradient(
                    cellX,
                    cellY,
                    cellX + this.cellSize,
                    cellY + this.cellSize
                  );
                  gradient.addColorStop(0, "#4f46e5");
                  gradient.addColorStop(0.5, "#3b82f6");
                  gradient.addColorStop(1, "#1e40af");

                  this.ctx.fillStyle = gradient;
                  this.ctx.fillRect(
                    cellX + 1,
                    cellY + 1,
                    this.cellSize - 2,
                    this.cellSize - 2
                  );

                  // Borde sutil
                  this.ctx.strokeStyle = "#06b6d4";
                  this.ctx.lineWidth = 0.5;
                  this.ctx.strokeRect(
                    cellX + 1,
                    cellY + 1,
                    this.cellSize - 2,
                    this.cellSize - 2
                  );
                  break;

                case 2: // Punto con brillo
                  const dotGradient = this.ctx.createRadialGradient(
                    cellX + this.cellSize / 2,
                    cellY + this.cellSize / 2,
                    0,
                    cellX + this.cellSize / 2,
                    cellY + this.cellSize / 2,
                    this.cellSize / 6
                  );
                  dotGradient.addColorStop(0, "#ffffff");
                  dotGradient.addColorStop(0.7, "#e2e8f0");
                  dotGradient.addColorStop(1, "#94a3b8");

                  this.ctx.fillStyle = dotGradient;
                  this.ctx.beginPath();
                  this.ctx.arc(
                    cellX + this.cellSize / 2,
                    cellY + this.cellSize / 2,
                    this.cellSize / 8,
                    0,
                    Math.PI * 2
                  );
                  this.ctx.fill();

                  // Efecto de brillo
                  this.ctx.shadowColor = "#ffffff";
                  this.ctx.shadowBlur = 3;
                  this.ctx.fill();
                  this.ctx.shadowBlur = 0;
                  break;

                case 3: // Power-up con animación
                  const powerGradient = this.ctx.createRadialGradient(
                    cellX + this.cellSize / 2,
                    cellY + this.cellSize / 2,
                    0,
                    cellX + this.cellSize / 2,
                    cellY + this.cellSize / 2,
                    this.cellSize / 3
                  );
                  powerGradient.addColorStop(0, "#06b6d4");
                  powerGradient.addColorStop(0.7, "#0891b2");
                  powerGradient.addColorStop(1, "#0e7490");

                  this.ctx.fillStyle = powerGradient;
                  this.ctx.beginPath();
                  this.ctx.arc(
                    cellX + this.cellSize / 2,
                    cellY + this.cellSize / 2,
                    this.cellSize / 4,
                    0,
                    Math.PI * 2
                  );
                  this.ctx.fill();

                  // Efecto de pulso
                  this.ctx.shadowColor = "#06b6d4";
                  this.ctx.shadowBlur = 8;
                  this.ctx.fill();
                  this.ctx.shadowBlur = 0;
                  break;
              }
            }
          }
        }

        drawPacman() {
          const x =
            this.offsetX + (this.pacmanSmoothPos.x + 0.5) * this.cellSize;
          const y =
            this.offsetY + (this.pacmanSmoothPos.y + 0.5) * this.cellSize;
          const radius = this.cellSize * 0.4;

          // Calcular ángulo de rotación basado en la dirección
          let rotation = 0;
          if (this.pacman.direction.x === 1) rotation = 0;
          else if (this.pacman.direction.x === -1) rotation = Math.PI;
          else if (this.pacman.direction.y === -1) rotation = -Math.PI / 2;
          else if (this.pacman.direction.y === 1) rotation = Math.PI / 2;

          // Gradiente para Pacman
          const pacmanGradient = this.ctx.createRadialGradient(
            x,
            y,
            0,
            x,
            y,
            radius
          );
          pacmanGradient.addColorStop(0, "#FFFF44");
          pacmanGradient.addColorStop(0.8, "#FFDD00");
          pacmanGradient.addColorStop(1, "#CCAA00");

          // Dibujar Pacman con gradiente
          this.ctx.fillStyle = pacmanGradient;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
          this.ctx.arc(
            x,
            y,
            radius,
            rotation + this.pacman.mouthAngle * Math.PI,
            rotation + (2 - this.pacman.mouthAngle) * Math.PI
          );
          this.ctx.lineTo(x, y);
          this.ctx.fill();

          // Borde sutil
          this.ctx.strokeStyle = "#FFAA00";
          this.ctx.lineWidth = 1;
          this.ctx.stroke();

          // Efecto de brillo
          this.ctx.shadowColor = "#FFFF00";
          this.ctx.shadowBlur = 5;
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
        }

        drawGhosts() {
          this.ghosts.forEach((ghost, index) => {
            const x =
              this.offsetX +
              (this.ghostSmoothPos[index].x + 0.5) * this.cellSize;
            const y =
              this.offsetY +
              (this.ghostSmoothPos[index].y + 0.5) * this.cellSize;
            const radius = this.cellSize * 0.4;

            // Gradiente para el fantasma
            const ghostGradient = this.ctx.createRadialGradient(
              x,
              y - radius / 2,
              0,
              x,
              y,
              radius
            );
            ghostGradient.addColorStop(0, ghost.color);
            ghostGradient.addColorStop(0.8, ghost.color);
            ghostGradient.addColorStop(1, this.darkenColor(ghost.color, 0.3));

            // Cuerpo del fantasma
            this.ctx.fillStyle = ghostGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, Math.PI, 0, false);
            this.ctx.lineTo(x + radius, y + radius);

            // Ondulaciones en la parte inferior más suaves
            const waveSize = radius / 4;
            for (let i = 0; i < 4; i++) {
              const waveX = x + radius - i * waveSize * 2;
              this.ctx.quadraticCurveTo(
                waveX,
                y + radius - waveSize / 2,
                waveX - waveSize,
                y + radius
              );
              this.ctx.quadraticCurveTo(
                waveX - waveSize,
                y + radius + waveSize / 2,
                waveX - waveSize * 2,
                y + radius
              );
            }

            this.ctx.lineTo(x - radius, y + radius);
            this.ctx.lineTo(x - radius, y);
            this.ctx.fill();

            // Borde sutil
            this.ctx.strokeStyle = this.darkenColor(ghost.color, 0.2);
            this.ctx.lineWidth = 0.5;
            this.ctx.stroke();

            // Ojos más grandes y expresivos
            this.ctx.fillStyle = "#FFFFFF";
            this.ctx.beginPath();
            this.ctx.arc(
              x - radius / 2.2,
              y - radius / 4,
              radius / 2.5,
              0,
              Math.PI * 2
            );
            this.ctx.arc(
              x + radius / 2.2,
              y - radius / 4,
              radius / 2.5,
              0,
              Math.PI * 2
            );
            this.ctx.fill();

            // Pupilas con dirección
            this.ctx.fillStyle = "#000000";

            let pupilOffsetX = 0;
            let pupilOffsetY = 0;

            if (ghost.direction.x > 0) pupilOffsetX = radius / 10;
            else if (ghost.direction.x < 0) pupilOffsetX = -radius / 10;

            if (ghost.direction.y > 0) pupilOffsetY = radius / 10;
            else if (ghost.direction.y < 0) pupilOffsetY = -radius / 10;

            this.ctx.beginPath();
            this.ctx.arc(
              x - radius / 2.2 + pupilOffsetX,
              y - radius / 4 + pupilOffsetY,
              radius / 8,
              0,
              Math.PI * 2
            );
            this.ctx.arc(
              x + radius / 2.2 + pupilOffsetX,
              y - radius / 4 + pupilOffsetY,
              radius / 8,
              0,
              Math.PI * 2
            );
            this.ctx.fill();

            // Efecto de brillo sutil
            this.ctx.shadowColor = ghost.color;
            this.ctx.shadowBlur = 3;
            this.ctx.fillStyle = ghostGradient;
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
          });
        }

        darkenColor(color, factor) {
          // Función para oscurecer un color
          const hex = color.replace("#", "");
          const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
          const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
          const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));

          return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        drawGameMessage(message, color) {
          // Fondo semitransparente con gradiente
          const bgGradient = this.ctx.createLinearGradient(
            0,
            0,
            0,
            this.canvas.height
          );
          bgGradient.addColorStop(0, "rgba(0, 0, 0, 0.8)");
          bgGradient.addColorStop(1, "rgba(15, 23, 42, 0.9)");

          this.ctx.fillStyle = bgGradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Mensaje principal con efecto de brillo
          const fontSize = this.isMobile ? "20px" : "28px";
          this.ctx.font = `bold ${fontSize} Arial`;
          this.ctx.fillStyle = color;
          this.ctx.textAlign = "center";
          this.ctx.textBaseline = "middle";
          this.ctx.shadowColor = color;
          this.ctx.shadowBlur = 10;
          this.ctx.fillText(
            message,
            this.canvas.width / 2,
            this.canvas.height / 2
          );
          this.ctx.shadowBlur = 0;

          // Instrucción de reinicio universal
          const instructionFontSize = this.isMobile ? "12px" : "16px";
          this.ctx.font = `${instructionFontSize} Arial`;
          this.ctx.fillStyle = "#06b6d4";
          this.ctx.shadowColor = "#06b6d4";
          this.ctx.shadowBlur = 5;

          this.ctx.fillText(
            "Presiona ESPACIO o toca para reiniciar",
            this.canvas.width / 2,
            this.canvas.height / 2 + (this.isMobile ? 30 : 40)
          );
          this.ctx.shadowBlur = 0;
        }
      }

      // Iniciar el juego cuando la página cargue
      window.addEventListener("load", () => {
        new PacmanGame();
      });
    </script>
  </body>
</html>
